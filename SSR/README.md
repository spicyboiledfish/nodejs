### React SSR

- SSR: Server Side Rendering 服务端渲染

- 优缺点：

  - 优点： 直出html页面会搜索引擎非常友好，首屏加载速度很快，爬虫很方便找到内容，有利于SEO
  - 缺点： 所有页面的加载需要向服务器请求完整的页面内容和资源，访问量较大的情况下对服务器有压力，页面之间的频繁刷新跳转体验不好

  

  CSR: 客户端渲染。web端主流的渲染模式，开发模式是SPA, 单页面应用.

  React SSR => SSR +SPA. 每次刷新页面的时候数据是从服务端直出，然后后续的访问就是 `spa` 的体验，即能解决`SEO`问题，也能保持页面切换的效率，服务器的压力要比传统的`ssr`也相对小

- API:

  - import ReactDOMServer from 'react-dom/server'; `ReactDOMServer` 类可以帮我们在服务端渲染组件 - 得到组件的 `html` 字符串
    - ReactDOMServer.renderToString(element) 把一个react组件渲染成为原始的HTML
  - ReactDOM.hydrate() 客户端渲染。
  - react16以后采用了renderToNodeStream。相比renderToString性能要好很多
    - 因为组件渲染为字符串，是一次性处理完后才开始向浏览器端返回结果。而采用流的话，可以边读边输出，可以要让页面更快的展现，缩短首屏展现时间

- 简单的html直出页面：

  - 实现方案：renderToString(<HelloWorld />)得到一个静态的html字符串。创建一个node服务，然后再有服务端res.end输出。但是如果增加交互的话，点击事件无法生效。
  - 原因：元素的事件都是基于浏览器执行的，只有在浏览器端执行了相应的js代码才能绑定事件。而我们之前写的只是一个静态页面。我们需要让代码在浏览器端也执行一次。组件在浏览器端挂载后react会自动完成事件绑定。
  - 浏览器也执行一次代码，组件会不会重复渲染？浏览器接管页面后，react-dom在渲染组件前会先和页面中的节点做对比，只有对比失败的情况下才会采用客户端的内容进行渲染，而且react也会尽可能多的复用已有的节点。

- 同构：以上我们说了服务端和客户端都要执行同一份代码，服务端直出组件后，浏览器接管页面，然后剩下的工作都交由浏览器来完成。这样的一套机制就是同构。
    - 双端对比的时候，浏览器端代码执行时生成的节点结构会和网页内已有的结构进行对比， 如果对比失败，就会采用客户端的结构。如果你在服务端渲染的代码html随便加入客户端不存在的一个div代码，那么会闪一下消失。 
    - 服务端渲染的组件和客户端渲染的组件的区别：服务端只是生成-html字符串，只会执行组件的componentWillMount方法。
    - 注意会报错：Did not expect server HTML to contain the text node " " in . 这是双端对比的时候有空格，在写中间件的时候，注意不要留空格。
    ```html
    <div id="root">
        ${html}
    </div>

    // 改成下面这样
    <div id="root">${html}</div>
    ```
    

- 双端代码自动编译和监听：
    - 前端代码仍然使用webpack打包，编译开启watch，可以监听文件变化并编译
    - 服务端代码可以使用webpack打包：
        - 需要配置target: "node"
        - 增加externals选项，使用webpack-node-externals来排除不需要打包的模块， 因为node会自动载入这些包，可以让打包的文件更小

- 双端实现路由同构：
    当第一次请求页面的时候，服务端接收请求，根据当前的path来查找具体的路由，然后根据路由得到具体的组件，然后将组件直出。服务端直出后，页面由浏览器接管，后面的渲染执行就交给前端代码了。

- 双端实现数据同构：
    - 数据同构： 组件的一些数据需要从接口异步获取后进行渲染，数据同构就是服务端和客户端能够使用同一个数据的请求处理方法，同一份数据进行组件的渲染。
    - componentDidMount生命周期只会在浏览器端执行，不会在服务端执行。 所以按照以往的方式在componentDidMount中去请求接口塞数据不可行。所以如果想让数据也能在服务端渲染就需要做一些特殊的处理。
    - 我们需要在服务端直出组件内容的时候要包含数据，需要提前获取数据，然后将数据作为属性传递给组件，这个就叫数据预取。
    - 浏览器上的fetch api在node端无法使用，需要采用一些同构的库，比方axios， isomorphic-fetch. 一般推荐使用axios.
    - 在JS中无论是函数还是类，都可以添加属性，而这个属性也可以被称为类的静态方法。静态方法的特点就是不需要实例化就可以访问。
      ```javascript
        class Foo {
            run() {
                console.log('run');
            }
        }
        Foo.method = function() {
            console.log('method');
        }
        //1. 可以直接调用静态方法，不需要实例
        Foo.method(); // method

        //2. 调用run方法，需要实例化
        let foo = new Foo();
        foo.run();  // run
      ```
    - 根据以上的方法，那么在node端我们就可以将Foo想象成我们的react组件，在node端找到这个组件，然后调用组件的静态方法来实现数据的预取。
    -  1. 约定并为组件添加数据预取的静态方法
       2. 在服务端查找到当前路由对应的组件
       3. 调用组件的数据预取方法得到数据
       4. 将数据作为属性传入组件
       5. 组件内render做相应的处理
       6. 服务端直出组件
       7. 浏览器接管页面，完成渲染
    - 我们在服务端直出组件的同时，需要将数据也输出给浏览器，这就叫数据脱水。
    - 在浏览器获取数据，就直接取JSON.parse(document.getElementById('ssr').value); 将数据和组件调和渲染的过程就是数据注水。

- SEO TDK支持
    - TDK: T: title当前页面的标题；D: description当前页面的描述; K: keywords当前页面的关键词.
    - 动态TDK: 数据预取中做手脚. 
      - 方法1： 在获取数据的同时，新增属性表示TDK，再带入到fetchResult里面，到页面后再解构。
      - 方法2： react-helmet组件


